package fxnum

import (
	"fmt"
	"github.com/robaho/fixed"
	"github.com/shopspring/decimal"
	"github.com/stretchr/testify/require"
	"math"
	"runtime"
	"strconv"
	"testing"
)

func Test_Order_Float64(t *testing.T) {
	a := 1e16
	b := -1e16
	c := 1.0

	r1 := (a + b) + c
	r2 := a + (b + c)

	fmt.Printf("(a + b) + c = %.17f\n", r1)
	fmt.Printf("a + (b + c) = %.17f\n", r2)
}

func Test_Order_Decimal(t *testing.T) {
	da := decimal.NewFromFloat(1e16)
	db := decimal.NewFromFloat(-1e16)
	dc := decimal.NewFromFloat(1.0)

	dr1 := da.Add(db).Add(dc)
	dr2 := da.Add(db.Add(dc))

	fmt.Printf("(a + b) + c = %v\n", dr1)
	fmt.Printf("a + (b + c) = %v\n", dr2)

	require.True(t, dr1.Equal(dr2))
}

func Test_Order_Fixed(t *testing.T) {
	fa := fixed.NewF(1e7)
	fb := fixed.NewF(-1e7)
	fc := fixed.NewF(1.0)

	fr1 := fa.Add(fb).Add(fc)
	fr2 := fa.Add(fb.Add(fc))

	fmt.Printf("(a + b) + c = %v\n", fr1)
	fmt.Printf("a + (b + c) = %v\n", fr2)

	require.True(t, fr1.Equal(fr2))
}

func Test_Subnormal_Float64(t *testing.T) {
	x := 1e-310 // subnormal
	y := 1.0
	z := x + y

	fmt.Printf("x = %.17g\n", x)
	fmt.Printf("z = x + 1 = %.17g\n", z)
	fmt.Printf("z - 1 = %.17g\n", z-1)
}

func Test_Subnormal_Decimal(t *testing.T) {
	x := decimal.NewFromFloat(1e-310) // subnormal
	y := decimal.NewFromFloat(1.0)
	z := x.Add(y)

	fmt.Printf("x = %v\n", x)
	fmt.Printf("z = x + 1 = %v\n", z)
	fmt.Printf("z - 1 = %v\n", z.Sub(decimal.New(1, 0)))

	require.True(t, x.Equal(decimal.New(1, -310)))
	require.True(t, y.Equal(decimal.NewFromInt(1)))
	require.True(t, z.Equal(decimal.NewFromInt(1).Add(decimal.New(1, -310))))
	require.False(t, z.Equal(decimal.Zero))
}

func Test_FMA_Float64(t *testing.T) {
	a := 1e16
	b := 1.000000000000001
	c := -1e16
	//    10000000000000010
	//	- 10000000000000000
	//  ---------------------
	//	= 10 <-- expected
	normal := a*b + c
	fma := math.FMA(a, b, c)

	fmt.Printf("normal: %.17f\n", normal)
	fmt.Printf("fma:    %.17f\n", fma)
}

func Test_FMA_Decimal(t *testing.T) {
	a := decimal.NewFromFloat(1e16)
	b := decimal.NewFromFloat(1.000000000000001)
	c := decimal.NewFromFloat(-1e16)
	//    10000000000000010
	//	- 10000000000000000
	//  ---------------------
	//	= 10 <-- expected

	normal := a.Mul(b).Add(c)
	fmt.Printf("normal: %v\n", normal)
	require.True(t, normal.Equal(decimal.NewFromInt(10)))
}

func Test_Golden_Decimal(t *testing.T) {
	// The following test cases are generated by Gemini 2.5 Flash.
	// But the 'want' values are computed using the `shopspring/decimal`(v1.4.0) package on
	//    GOOS: darwin
	//    GOARCH: arm64
	//    Go Ver: go1.23.1
	//    CPU: Apple M1
	data := []struct {
		base, exp, out string
	}{
		{"2.0000000", "3.5000000", "11.313708498984760390408"},
		{"4.0000000", "0.5000000", "2"},
		{"2.0000000", "2.0000000", "4"},
		{"1.0000000", "5.6789000", "1"},
		{"10.0000000", "-1.0000000", "0.1"},
		{"2.0000000", "0.5000000", "1.414213562373095048801"},  // 1.4142135 62
		{"3.0000000", "1.5000000", "5.196152422706631880581"},  // 5.1961524 23
		{"1.5000000", "2.5000000", "2.7556759606310753604705"}, // 2.7556758 65
		{"2.7182818", "1.0000000", "2.7182818"},
		{"1.0000001", "100.0000000", "1.0000100000495001617003921232528763920540007579408808452335394323619430968577621613918496001118419361180460608588960551508620569726202410987692961484655664217463365388944649757066153627437443498295295736356143238323898970848789779332511575560895364648375476461074133458834391002947092994606741491389504904351863645596670542540199293179530140928892936827194028987876919159191037449386374638480074989715737416229572237053600485222684850681491414650722451920661507030366096997978156248006931352234215989978126053623426229262582512701236932738027352470489396728353634142001709052326723806622268682978837786048413065269680637463096466631827008789590075609192052407528752039212250161700000495000001000000001"},
	}

	fmt.Println("---- SYSTEM INFO ----")
	fmt.Println("Go Version :", runtime.Version())
	fmt.Println("GOARCH      :", runtime.GOARCH)
	fmt.Println("GOOS        :", runtime.GOOS)

	for _, rec := range data {
		//
		// computed by decimal.Decimal
		b, err := decimal.NewFromString(rec.base)
		require.NoError(t, err)
		e, err := decimal.NewFromString(rec.exp)
		require.NoError(t, err)
		want, err := decimal.NewFromString(rec.out)
		require.NoError(t, err)

		got := b.Pow(e)
		//fmt.Printf("shopspring/decimal - base: %v, exponent: %v, want: %v (got: %v)\n", b, e, want, got)
		require.True(t, got.Equal(want), fmt.Sprintf("mismatch on %v^%v; want %v(got: %v)", rec.base, rec.exp, rec.out, got))
	}
}

func Test_Golden_Fixed(t *testing.T) {
	// The following test cases are generated by Gemini 2.5 Flash.
	// But the 'want' values are computed using `robaho/fixed`(1.0.3) package on
	//    GOOS: darwin
	//    GOARCH: arm64
	//    Go Ver: go1.23.1
	//    CPU: Apple M1
	data := []struct {
		base, exp, out string
	}{
		{"2.0000000", "3.5000000", "11.313694"},
		{"4.0000000", "0.5000000", "1.9999996"},
		{"2.0000000", "2.0000000", "3.999997"},
		{"1.0000000", "5.6789000", "1"},
		{"10.0000000", "-1.0000000", "0.1000001"},
		{"2.0000000", "0.5000000", "1.4142133"},
		{"3.0000000", "1.5000000", "5.1961519"},
		{"1.5000000", "2.5000000", "2.7556766"},
		{"2.7182818", "1.0000000", "2.7182818"},
		{"1.0000001", "100.0000000", "1"},
	}

	fmt.Println("---- SYSTEM INFO ----")
	fmt.Println("Go Version :", runtime.Version())
	fmt.Println("GOARCH      :", runtime.GOARCH)
	fmt.Println("GOOS        :", runtime.GOOS)

	for _, rec := range data {
		b, err := fixed.Parse(rec.base)
		require.NoError(t, err)
		e, err := fixed.Parse(rec.exp)
		require.NoError(t, err)
		want, err := fixed.Parse(rec.out)
		require.NoError(t, err)
		got, err := FixedPow(b, e)
		require.NoError(t, err)
		//fmt.Printf("robaho/fixed - base: %v, exponent: %v, want: %v (got: %v)\n", b, e, want, got)
		require.True(t, got.Equal(want), fmt.Sprintf("mismatch on %v^%v; want %v(got: %v)", rec.base, rec.exp, rec.out, got))
	}

}

func Test_Golden_Float(t *testing.T) {
	// The following test cases are generated by Gemini 2.5 Flash.
	// But the 'want' values are computed using `float64` on
	//    GOOS: darwin
	//    GOARCH: arm64
	//    Go Ver: go1.23.1
	//    CPU: Apple M1
	data := []struct {
		base, exp, out string
	}{
		{"2.0000000", "3.5000000", "11.31370849898476"},
		{"2.0000000", "2.0000000", "4"},
		{"1.0000000", "5.6789000", "1"},
		{"4.0000000", "0.5000000", "2"},
		{"10.0000000", "-1.0000000", "0.1"},
		{"2.0000000", "0.5000000", "1.4142135623730951"},
		{"3.0000000", "1.5000000", "5.196152422706632"},
		{"1.5000000", "2.5000000", "2.7556759606310752"},
		{"2.7182818", "1.0000000", "2.7182818"},
		{"1.0000001", "100.0000000", "1.0000100000495054"},
	}

	fmt.Println("---- SYSTEM INFO ----")
	fmt.Println("Go Version :", runtime.Version())
	fmt.Println("GOARCH      :", runtime.GOARCH)
	fmt.Println("GOOS        :", runtime.GOOS)

	for _, rec := range data {
		b, err := strconv.ParseFloat(rec.base, 64)
		require.NoError(t, err)
		e, err := strconv.ParseFloat(rec.exp, 64)
		require.NoError(t, err)
		want, err := strconv.ParseFloat(rec.out, 64)
		require.NoError(t, err)
		got := math.Pow(b, e)
		if want != got {
			fmt.Printf("❗❗❗float64 - base: %g, exponent: %g, want: %g (got: %g)\n", b, e, want, got)
		}
		//require.Equal(t, want, got, fmt.Sprintf("mismatch on %v^%v; want %v(got: %v)", rec.base, rec.exp, rec.out, got))
	}
}

func Test_NonDetPow2(t *testing.T) {
	// float64
	// 22.4591577183610 41133903199806809 on macOS(Sequoia 15.5, darwin(arm64, Apple M1)
	// 22.4591577183610 37581189521006308 on Ubuntu 22.04.5 LTS, linux(amd64)
	base0 := math.Pi
	exp0 := math.E

	result0 := math.Pow(base0, exp0)
	fmt.Printf("math.Pow(math.Pi, math.E) = %.30f\n", result0)

	// decimal.Decimal
	base1 := decimal.NewFromFloat(math.Pi)
	exp1 := decimal.NewFromFloat(math.E)
	expected1 := "22.4591577183610347883664603263249777185600434355356534860802406084294"
	result1 := base1.Pow(exp1)
	fmt.Printf("decimal.Pow(math.Pi, math.E) = %v\n", result1)
	require.Equal(t, expected1, result1.String())

	// fixed.Fixed
	base2 := fixed.NewF(math.Pi)
	exp2 := fixed.NewF(math.E)
	expected2 := "22.4591642"

	result2, err := FixedPow(base2, exp2)
	require.NoError(t, err)
	fmt.Printf("fxnum.FixedPow(math.Pi, math.E) = %v\n", result2)
	require.Equal(t, expected2, result2.String())
}
